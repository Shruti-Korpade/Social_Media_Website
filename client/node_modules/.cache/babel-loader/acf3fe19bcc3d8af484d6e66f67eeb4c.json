{"ast":null,"code":"import { getBatch } from './batch'; // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\nfunction createListenerCollection() {\n  const batch = getBatch();\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n\n    notify() {\n      batch(() => {\n        let listener = first;\n\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n\n    get() {\n      let listeners = [];\n      let listener = first;\n\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n\n      return listeners;\n    },\n\n    subscribe(callback) {\n      let isSubscribed = true;\n      let listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n\n  };\n}\n\nconst nullListeners = {\n  notify() {},\n\n  get: () => []\n};\nexport function createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners; // Reasons to keep the subscription active\n\n  let subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)\n\n  let selfSubscribed = false;\n\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener); // cleanup nested sub\n\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++;\n\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = undefined;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n}","map":{"version":3,"sources":["C:/Users/kskor/OneDrive/Desktop/SHRUTI/Sem 5/WT/client/node_modules/react-redux/es/utils/Subscription.js"],"names":["getBatch","createListenerCollection","batch","first","last","clear","notify","listener","callback","next","get","listeners","push","subscribe","isSubscribed","prev","unsubscribe","nullListeners","createSubscription","store","parentSub","subscriptionsAmount","selfSubscribed","addNestedSub","trySubscribe","cleanupListener","removed","tryUnsubscribe","notifyNestedSubs","handleChangeWrapper","subscription","onStateChange","undefined","trySubscribeSelf","tryUnsubscribeSelf","getListeners"],"mappings":"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","sourcesContent":["import { getBatch } from './batch'; // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\nfunction createListenerCollection() {\n  const batch = getBatch();\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n\n    notify() {\n      batch(() => {\n        let listener = first;\n\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n\n    get() {\n      let listeners = [];\n      let listener = first;\n\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n\n      return listeners;\n    },\n\n    subscribe(callback) {\n      let isSubscribed = true;\n      let listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n\n  };\n}\n\nconst nullListeners = {\n  notify() {},\n\n  get: () => []\n};\nexport function createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners; // Reasons to keep the subscription active\n\n  let subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)\n\n  let selfSubscribed = false;\n\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener); // cleanup nested sub\n\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++;\n\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = undefined;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n}"]},"metadata":{},"sourceType":"module"}